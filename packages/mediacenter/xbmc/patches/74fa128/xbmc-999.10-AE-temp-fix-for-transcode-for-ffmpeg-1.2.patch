From ca168271c6dac107b636dde42e166b5e505b6f4c Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 12 Apr 2013 21:01:24 +0200
Subject: [PATCH] AE: temp fix for transcode after ffmpeg update

---
 .../cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp | 87 +++++++++++++++++++---
 xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h  |  2 +
 2 files changed, 77 insertions(+), 12 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
index 34ddda6..b2d0b75 100644
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
@@ -143,16 +143,47 @@ bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
     bool hasS32    = false;
     bool hasS16    = false;
     bool hasU8     = false;
+    m_IsPlanar     = false;
 
     for(int i = 0; codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; ++i)
     {
       switch (codec->sample_fmts[i])
       {
-        case AV_SAMPLE_FMT_FLT: hasFloat  = true; break;
-        case AV_SAMPLE_FMT_DBL: hasDouble = true; break;
-        case AV_SAMPLE_FMT_S32: hasS32    = true; break;
-        case AV_SAMPLE_FMT_S16: hasS16    = true; break;
-        case AV_SAMPLE_FMT_U8 : hasU8     = true; break;
+        case AV_SAMPLE_FMT_FLT:
+          hasFloat  = true;
+          break;
+        case AV_SAMPLE_FMT_FLTP:
+          hasFloat  = true;
+          m_IsPlanar = true;
+          break;
+        case AV_SAMPLE_FMT_DBL:
+          hasDouble = true;
+          break;
+        case AV_SAMPLE_FMT_DBLP:
+          hasDouble = true;
+          m_IsPlanar = true;
+          break;
+        case AV_SAMPLE_FMT_S32:
+          hasS32    = true;
+          break;
+        case AV_SAMPLE_FMT_S32P:
+          hasS32    = true;
+          m_IsPlanar = true;
+          break;
+        case AV_SAMPLE_FMT_S16:
+          hasS16    = true;
+          break;
+        case AV_SAMPLE_FMT_S16P:
+          hasS16    = true;
+          m_IsPlanar = true;
+          break;
+        case AV_SAMPLE_FMT_U8:
+          hasU8     = true;
+          break;
+        case AV_SAMPLE_FMT_U8P:
+          hasU8     = true;
+          m_IsPlanar = true;
+          break;
 
         default:
           return false;
@@ -161,27 +192,42 @@ bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
 
     if (hasFloat)
     {
-      m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_FLT;
+      if (m_IsPlanar)
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_FLTP;
+      else
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_FLT;
       format.m_dataFormat    = AE_FMT_FLOAT;
     }
     else if (hasDouble)
     {
-      m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_DBL;
+      if (m_IsPlanar)
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_DBLP;
+      else
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_DBL;
       format.m_dataFormat    = AE_FMT_DOUBLE;
     }
     else if (hasS32)
     {
-      m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_S32;
+      if (m_IsPlanar)
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_S32P;
+      else
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_S32;
       format.m_dataFormat    = AE_FMT_S32NE;
     }
     else if (hasS16)
     {
-      m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_S16;
+      if (m_IsPlanar)
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_S16P;
+      else
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_S16;
       format.m_dataFormat    = AE_FMT_S16NE;
     }
     else if (hasU8)
     {
-      m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_U8;
+      if (m_IsPlanar)
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_U8P;
+      else
+        m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_U8;
       format.m_dataFormat    = AE_FMT_U8;
     }
     else
@@ -241,8 +287,25 @@ int CAEEncoderFFmpeg::Encode(float *data, unsigned int frames)
   if (!m_CodecCtx || frames < m_NeededFrames)
     return 0;
 
-  /* encode it */
-  int size = m_dllAvCodec.avcodec_encode_audio(m_CodecCtx, m_Buffer + IEC61937_DATA_OFFSET, FF_MIN_BUFFER_SIZE, (short*)data);
+  int size = 0;
+  // planar format
+  if (m_IsPlanar)
+  {
+    int src = 0;
+    int dst = 0;
+    for (int i = 0; i < 1536; i++)
+    {
+      for (int j = 0; j < 6; j++)
+      {
+        memcpy(m_PlanarBuffer+(j*1536*4+dst), (uint8_t*)data+src, 4);
+        src += 4;
+      }
+      dst += 4;
+    }
+    size = m_dllAvCodec.avcodec_encode_audio(m_CodecCtx, m_Buffer + IEC61937_DATA_OFFSET, FF_MIN_BUFFER_SIZE, (short*)m_PlanarBuffer);
+  }
+  else
+    size = m_dllAvCodec.avcodec_encode_audio(m_CodecCtx, m_Buffer + IEC61937_DATA_OFFSET, FF_MIN_BUFFER_SIZE, (short*)data);
 
   /* pack it into an IEC958 frame */
   m_BufferSize = m_PackFunc(NULL, size, m_Buffer);
diff --git a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
index 0cedf3f..90b0147 100644
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
@@ -65,6 +65,8 @@ class CAEEncoderFFmpeg: public IAEEncoder
   double            m_SampleRateMul;
 
   unsigned int      m_NeededFrames;
+  bool              m_IsPlanar;
+  uint8_t           m_PlanarBuffer[1536*6*4];
 
   unsigned int BuildChannelLayout(const int64_t ffmap, CAEChannelInfo& layout);
 };
-- 
1.8.1.5

